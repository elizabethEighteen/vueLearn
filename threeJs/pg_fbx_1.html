<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>学习</title>
  </head>
  <body>
    <canvas id="c2d" class="c2d" width="1600" height="800"></canvas>
    <script type="module">
      import * as THREE from "./file/three.js-dev/build/three.module.js";
      import { OrbitControls } from "./file/three.js-dev/examples/jsm/controls/OrbitControls.js";
      import { FBXLoader } from "./file/three.js-dev/examples/jsm/loaders/FBXLoader.js";
      let actions = []; // 所有的动画数组
      let gui = {}; // 动画控制
      let mixer = null; // AnimationMixer 对象
      let meshHY = null;

      const canvas = document.querySelector("#c2d");
      // 渲染器
      const renderer = new THREE.WebGLRenderer({ canvas });
      // 开启阴影
      renderer.shadowMap.enabled = true;

      const fov = 40; // 视野范围
      const aspect = 2; // 相机默认值 画布的宽高比
      const near = 0.1; // 近平面
      const far = 10000; // 远平面
      // 透视投影相机
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      camera.position.set(-1000, 200, 2500);
      camera.lookAt(0, 0, 0);
      // 控制相机
      const controls = new OrbitControls(camera, canvas);
      controls.update();

      // 场景
      const scene = new THREE.Scene();

      {
        // 灯光
        const skyColor = 0xffffff; // 天空 白色
        const groundColor = 0x000000; // 地面 黑色
        const intensity = 1;
        const light = new THREE.HemisphereLight(
          skyColor,
          groundColor,
          intensity
        );
        scene.add(light);
      }
      let dLight = null;
      {
        const light = new THREE.DirectionalLight(0xaaaaaa);
        light.position.set(0, 200, 100);
        light.lookAt(new THREE.Vector3());

        light.castShadow = true;
        light.shadow.camera.top = 300;
        light.shadow.camera.bottom = -300;
        light.shadow.camera.left = -300;
        light.shadow.camera.right = 300;

        // 开启阴影投射
        light.castShadow = true;
        dLight = light;
        scene.add(light);
      }

      let xiaotuiche = null;
      let menzhong = null;
      let menshang = null;
      let youmen = null;
      let tuicheshi = null;
      const loader = new FBXLoader();
      loader.load("./file/zhuti.fbx", function (mesh) {
        console.log("mesh", mesh);
        // 设置模型的每个部位都可以投影
        mesh.traverse(function (child) {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
          if (child.name === "小推车") {
            xiaotuiche = child;
            console.log(child, "小推车");
          }
          if (child.name === "门_中") {
            menzhong = child;
            console.log(child, "门中");
          }
          if (child.name === "门_上") {
            menshang = child;
            console.log(child, "门上");
          }
          if (child.name === "右门") {
            youmen = child;
          }
          if (child.name === "推车室") {
            tuicheshi = child;
            console.log(tuicheshi);
          }
        });

        // 设置光线焦点模型
        dLight.target = mesh;
        meshHY = mesh;
        scene.add(mesh);
      });
      function setInitStyle(el, key, key1, value) {
        if (el && el[key]) {
          if (el.init) return;
          el[key][key1] = value;
          el.init = true;
        }
      }
      function setInitStyleSimple(el, key, value) {
        if (el) {
          if (el.init) return;
          el.init = true;
          el[key] = value;
        }
      }
      function animationNegativeRotation(el, key, key1, mostValue,step, callback) {
        if (el && el[key]) {
          // console.log(el[key][key1],mostValue,'key')
          // console.log(el[key][key1] > mostValue)
          if (el[key][key1] > mostValue) {
            // console.log(el[key][key1]);
            el[key][key1] = el[key][key1] - step;
          }else {
            callback()
          }
        }
      }
      // 渲染
      let isMenzhongAnimationDone = false;
      let isXiaotuicheAnimationDone = false
      let isMenShangOpenAnimationDone = false
      function render() {
        {
          // 设置初始化位置
          // setInitStyle(menshang, "rotation", "y", -Math.PI / 2);
          // setInitStyle(menzhong, "rotation", "y", -Math.PI / 2);
          setInitStyle(tuicheshi, "position", "x", -800);
          setInitStyle(xiaotuiche, "position", "x", -800);
          // setInitStyleSimple(youmen, "visible", false);
        }
        {
          // 门中打开动画
          animationNegativeRotation(
            menzhong,
            "rotation",
            "y",
            -Math.PI / 2,
            0.02,
            function () {
              isMenzhongAnimationDone = true;
            }
          );
        }

        {
          // 小推车移动动画
          if (
            isMenzhongAnimationDone &&
            xiaotuiche &&
            xiaotuiche.position &&
            xiaotuiche.position.x &&
            xiaotuiche.init
          ) {
            if (xiaotuiche.position.x < -145) {
              xiaotuiche.position.x = xiaotuiche.position.x + 5;
              // console.log(xiaotuiche.position.x);
            }else {
              isXiaotuicheAnimationDone = true
            }
          }
          // 推车室
          if (
            isMenzhongAnimationDone &&
            tuicheshi &&
            tuicheshi.position &&
            tuicheshi.position.x &&
            tuicheshi.init
          ) {
            if (tuicheshi.position.x < -145) {
              tuicheshi.position.x = tuicheshi.position.x + 5;
              // console.log(tuicheshi.position.x);
            }
          }
        }
        {
          //打开上门，隐藏右门
          if(isXiaotuicheAnimationDone) {
            animationNegativeRotation(
            menshang,
            "rotation",
            "y",
            -Math.PI / 2,
            0.02,
            function () {
              isMenShangOpenAnimationDone = true;
            }
          );
          youmen && (youmen.visible = false)
          }
        }
        {
          // 推车室进入动画
          if(isMenShangOpenAnimationDone) {
            if(tuicheshi.position.x < 140) {
              tuicheshi.position.x = tuicheshi.position.x + 5;
            }
          }
        }

        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
